<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xiangqi Master</title>
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #2c3e50 0%, #4ca1af 100%);
            --glass-panel: rgba(255, 255, 255, 0.15);
            --glass-border: rgba(255, 255, 255, 0.2);
            --board-color: #eecfa1;
            --line-color: #5d4037;
            
            /* NATURAL HIGHLIGHTS (SUBTLER) */
            --highlight-last: rgba(60, 100, 180, 0.3); 
            --highlight-select: rgba(210, 105, 30, 0.3); /* Reduced opacity for selection color */
            --highlight-valid: rgba(93, 64, 55, 0.2); /* Reduced opacity for target dots */
            
            --cell-size: 60px;
            --piece-size: 52px;
        }

        body {
            font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-gradient);
            color: #fff;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            font-weight: 200;
            letter-spacing: 6px;
            margin: 20px 0;
            text-transform: uppercase;
            text-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .main-container {
            display: flex; gap: 40px; justify-content: center; align-items: flex-start;
            flex-wrap: wrap; padding-bottom: 50px;
        }

        /* --- BOARD --- */
        .board-frame {
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }

        .board-wrapper {
            position: relative;
            width: calc(var(--cell-size) * 8 + var(--cell-size));
            height: calc(var(--cell-size) * 9 + var(--cell-size));
            background-color: var(--board-color);
            /* Wood Grain Texture */
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.07'/%3E%3C/svg%3E");
            border-radius: 4px;
            user-select: none;
            box-shadow: inset 0 0 20px rgba(93, 64, 55, 0.5);
        }

        svg.board-grid {
            position: absolute; top: 30px; left: 30px;
            width: calc(100% - 60px); height: calc(100% - 60px);
            pointer-events: none;
        }
        
        line, rect, path {
            stroke: var(--line-color); stroke-width: 2; fill: none; stroke-linecap: square;
        }

        .river-text {
            font-family: "KaiTi", "STKaiti", serif; font-size: 32px; fill: var(--line-color);
            opacity: 0.6; text-anchor: middle; dominant-baseline: middle;
        }

        /* --- LAYERS --- */
        .interaction-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }

        .cell {
            position: absolute;
            width: 11.11%; height: 10%;
            cursor: pointer;
            z-index: 15;
        }

        /* Markers - Subtle Glow Style */
        .marker {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; 
            z-index: 5;
            transition: all 0.15s ease-out;
        }
        .marker.last { 
            width: 12px; height: 12px; border-radius: 50%;
            background-color: var(--highlight-last);
            box-shadow: 0 0 5px var(--highlight-last);
        }
        
        /* ADJUSTED: SUBTLER CIRCULAR SELECTION GLOW with Tighter Radius */
        .marker.selected { 
            width: 85%; /* Base element size slightly larger than the piece */
            height: 85%; 
            /* Soft radial gradient for internal glow (Reduced Opacity) */
            background: radial-gradient(circle at center, rgba(255, 220, 180, 0.15) 0%, var(--highlight-select) 60%, transparent 100%);
            border-radius: 50%; 
            /* Subtle external shadow - tighter spread (10px spread gives the 1.5x effect) */
            box-shadow: 0 0 1px 10px rgba(210, 105, 30, 0.15); 
            opacity: 0.9;
        }
        
        /* SUBTLER VALID MOVE DOT WITH GLOW */
        .marker.valid {
            width: 16px; height: 16px; border-radius: 50%;
            background-color: var(--highlight-valid);
            /* Soft amber/gold outer glow (Reduced Spread/Opacity) */
            box-shadow: 0 0 3px 1px rgba(255, 193, 7, 0.08); 
            border: 1px solid rgba(255, 255, 255, 0.2); /* Reduced Border Opacity */
        }

        /* --- PIECES --- */
        .piece {
            width: var(--piece-size); height: var(--piece-size);
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 20;
            display: flex; justify-content: center; align-items: center;
            font-family: "KaiTi", "STKaiti", serif; font-size: 28px; font-weight: bold;
            pointer-events: none; /* Allows clicks to pass to cell */
            box-shadow: 0 4px 6px rgba(0,0,0,0.4), inset 0 2px 5px rgba(255,255,255,0.4);
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .piece.red { background: #fdfdfd; color: #c0392b; border: 2px solid #e57373; text-shadow: 0 1px 0 rgba(255,255,255,0.6); }
        .piece.black { background: #262626; color: #eee; border: 2px solid #555; text-shadow: 0 -1px 0 rgba(0,0,0,0.8); }
        .piece::before { content: ''; position: absolute; top: 3px; left: 3px; right: 3px; bottom: 3px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.1); }
        .piece.black::before { border-color: rgba(255,255,255,0.15); }

        /* --- SIDEBAR --- */
        .sidebar { width: 340px; display: flex; flex-direction: column; gap: 20px; }
        .glass-panel {
            background: var(--glass-panel); border: 1px solid var(--glass-border);
            border-radius: 8px; padding: 20px; backdrop-filter: blur(15px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .status-box { text-align: center; font-size: 1.2rem; padding-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); margin-bottom: 15px; font-weight: 600; }
        .history-box {
            height: 250px; overflow-y: auto; font-family: "Segoe UI", sans-serif; font-size: 14px;
            background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px; margin-bottom: 15px;
        }
        .move-row { display: flex; justify-content: space-between; padding: 4px 8px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        
        textarea {
            width: 100%; height: 80px; background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 6px;
            padding: 8px; font-family: monospace; resize: none; margin-bottom: 10px; outline: none;
        }
        .btn-row { display: flex; gap: 10px; flex-wrap: wrap; }
        button {
            flex: 1; padding: 10px; background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2); color: white; border-radius: 6px;
            cursor: pointer; font-weight: 600; font-size: 0.85rem; transition: all 0.2s;
        }
        button:hover { background: rgba(255,255,255,0.25); }

        #splash {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.3s; z-index: 100;
        }
        #splash.active { opacity: 1; }
        .splash-text {
            font-family: "KaiTi", serif; font-size: 6rem; color: #ff3b30;
            background: rgba(0,0,0,0.9); padding: 40px 80px; border-radius: 20px;
            text-shadow: 0 0 30px #d32f2f; transform: scale(0.5); border: 2px solid #d32f2f;
        }
        #splash.active .splash-text { transform: scale(1); }
        
        /* File Input Hidden */
        #file-selector { display: none; }
    </style>
</head>
<body>

    <h1>Xiangqi Master</h1>

    <div class="main-container">
        <div class="board-frame">
            <div class="board-wrapper">
                <svg class="board-grid" viewBox="0 0 400 450">
                    <rect x="0" y="0" width="400" height="450" stroke-width="4" />
                    <line x1="50" y1="0" x2="50" y2="200" /><line x1="50" y1="250" x2="50" y2="450" />
                    <line x1="100" y1="0" x2="100" y2="200" /><line x1="100" y1="250" x2="100" y2="450" />
                    <line x1="150" y1="0" x2="150" y2="200" /><line x1="150" y1="250" x2="150" y2="450" />
                    <line x1="200" y1="0" x2="200" y2="200" /><line x1="200" y1="250" x2="200" y2="450" />
                    <line x1="250" y1="0" x2="250" y2="200" /><line x1="250" y1="250" x2="250" y2="450" />
                    <line x1="300" y1="0" x2="300" y2="200" /><line x1="300" y1="250" x2="300" y2="450" />
                    <line x1="350" y1="0" x2="350" y2="200" /><line x1="350" y1="250" x2="350" y2="450" />
                    <line x1="0" y1="50" x2="400" y2="50" /><line x1="0" y1="100" x2="400" y2="100" />
                    <line x1="0" y1="150" x2="400" y2="150" /><line x1="0" y1="200" x2="400" y2="200" />
                    <line x1="0" y1="250" x2="400" y2="250" /><line x1="0" y1="300" x2="400" y2="300" />
                    <line x1="0" y1="350" x2="400" y2="350" /><line x1="0" y1="400" x2="400" y2="400" />
                    <line x1="150" y1="0" x2="250" y2="100" /><line x1="250" y1="0" x2="150" y2="100" />
                    <line x1="150" y1="350" x2="250" y2="450" /><line x1="250" y1="350" x2="150" y2="450" />
                    <text x="100" y="225" class="river-text">楚 河</text>
                    <text x="300" y="225" class="river-text">漢 界</text>
                </svg>
                <div class="interaction-layer" id="gridLayer"></div>
            </div>
        </div>

        <div class="sidebar">
            <div class="glass-panel">
                <div id="status" class="status-box">Red's Turn</div>
                <div id="moveHistory" class="history-box"></div>
                <div class="btn-row">
                    <button style="background:#c0392b" onclick="game.reset()">Reset</button>
                    <button onclick="game.undo()">Undo</button>
                </div>
            </div>

            <div class="glass-panel">
                <div style="font-size:0.8rem; margin-bottom:5px; opacity:0.7;">Game Data (Text Export)</div>
                <textarea id="ioInput" placeholder="Exported text will appear here..."></textarea>
                
                <input type="file" id="file-selector" accept=".xqpro,.txt" onchange="game.loadFile(event)">
                
                <div class="btn-row">
                    <button style="background:#27ae60" onclick="document.getElementById('file-selector').click()">Load .xqpro</button>
                    <button onclick="game.exportXQPro()">Save .xqpro</button>
                </div>
                 <div class="btn-row" style="margin-top:10px">
                    <button onclick="game.loadFromInput()">Load Text/DPXQ</button>
                    <button onclick="game.exportText()">Export Text</button>
                </div>
            </div>
        </div>
    </div>

    <div id="splash"><div class="splash-text">將軍</div></div>

<script>
/** AUDIO */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const t = audioCtx.currentTime;
    const mkOsc = (freq, type, dur, vol) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, t);
        gain.gain.setValueAtTime(vol, t); gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(t); osc.stop(t + dur);
    };
    if (type === 'move' || type === 'capture') { mkOsc(200, 'sine', 0.15, 0.5); mkOsc(50, 'square', 0.05, 0.2); }
    else if (type === 'check') { mkOsc(800, 'triangle', 0.6, 0.3); }
}

/** CHINESE NOTATION DATA (For Text Export Only) */
const CN_CHARS = { 'rR':'俥','rN':'傌','rE':'相','rA':'仕','rK':'帥','rC':'炮','rP':'兵', 'bR':'車','bN':'馬','bE':'象','bA':'士','bK':'將','bC':'炮','bP':'卒', '+':'进','-':'退','=':'平', 'F':'前','M':'中','B':'后' };
const CN_NUMS = ['零','一','二','三','四','五','六','七','八','九'];
const CN_DIGITS_FULL = ['０','１','２','３','４','５','６','７','８','９'];
function toCNFile(n, isRed) { return isRed ? CN_NUMS[n] : CN_DIGITS_FULL[n]; }
function toCNNum(n, isRed) { return isRed ? CN_NUMS[n] : CN_DIGITS_FULL[n]; }

class XiangqiEngine {
    constructor() { this.reset(); }
    reset() {
        this.board = Array(10).fill(null).map(() => Array(9).fill(null));
        this.turn = 'r';
        this.history = [];
        this.initialFen = "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1";
        this.loadFEN(this.initialFen);
    }
    getPiece(x, y) { if(x<0||x>8||y<0||y>9)return null; return this.board[y][x]; }
    loadFEN(fen) {
        this.board = Array(10).fill(null).map(() => Array(9).fill(null));
        const parts = fen.split(' ');
        const rows = parts[0].split('/');
        const map = {'R':'rR','N':'rN','B':'rE','A':'rA','K':'rK','C':'rC','P':'rP','r':'bR','n':'bN','b':'bE','a':'bA','k':'bK','c':'bC','p':'bP'};
        for(let y=0; y<10; y++) {
            let x = 0; const row = rows[y]||"";
            for(let i=0; i<row.length; i++) {
                const c = row[i];
                if(!isNaN(c)) x += parseInt(c); else { if(map[c]) this.board[y][x] = map[c]; x++; }
            }
        }
        this.turn = (parts[1] === 'b') ? 'b' : 'r';
        if(this.history.length === 0) this.initialFen = fen;
    }
    getFEN() {
        let fen = ""; const map = {'rR':'R','rN':'N','rE':'B','rA':'A','rK':'K','rC':'C','rP':'P','bR':'r','bN':'n','bE':'b','bA':'a','bK':'k','bC':'c','bP':'p'};
        for(let y=0; y<10; y++) {
            let empty = 0;
            for(let x=0; x<9; x++) {
                const p = this.board[y][x];
                if(!p) empty++; else { if(empty>0) { fen+=empty; empty=0; } fen+=map[p]; }
            }
            if(empty>0) fen+=empty; if(y<9) fen+="/";
        }
        return fen + " " + (this.turn==='r'?'w':'b') + " - - 0 1"; 
    }
    move(fx, fy, tx, ty) {
        const p = this.getPiece(fx, fy);
        if(!p || p[0] !== this.turn) return { success: false };
        if(!this.validate(fx, fy, tx, ty, p)) return { success: false };

        const wxf = this.getWXFNotation(fx, fy, tx, ty, p);
        const cn = this.getChineseNotation(fx, fy, tx, ty, p);
        
        const captured = this.board[ty][tx];
        this.board[ty][tx] = p;
        this.board[fy][fx] = null;
        
        if(this.isInCheck(this.turn)) {
            this.board[fy][fx] = p; this.board[ty][tx] = captured;
            return { success: false };
        }
        
        this.history.push({ fx, fy, tx, ty, captured, p, notation: wxf, cnNotation: cn });
        this.turn = (this.turn==='r')?'b':'r';
        return { success: true, capture: !!captured, check: this.isInCheck(this.turn) };
    }
    undo() {
        if(!this.history.length) return false;
        const last = this.history.pop();
        this.board[last.fy][last.fx] = last.p;
        this.board[last.ty][last.tx] = last.captured;
        this.turn = last.p[0];
        return true;
    }
    getValidMoves(fx, fy) {
        const p = this.getPiece(fx, fy);
        if (!p || p[0] !== this.turn) return [];
        const moves = [];
        for (let ty = 0; ty < 10; ty++) {
            for (let tx = 0; tx < 9; tx++) {
                if (this.validate(fx, fy, tx, ty, p)) {
                    const captured = this.getPiece(tx, ty);
                    this.board[ty][tx] = p; this.board[fy][fx] = null;
                    if (!this.isInCheck(p[0])) moves.push({ x: tx, y: ty });
                    this.board[fy][fx] = p; this.board[ty][tx] = captured;
                }
            }
        }
        return moves;
    }
    validate(fx, fy, tx, ty, p) {
        if(fx===tx && fy===ty) return false;
        const target = this.getPiece(tx, ty);
        if(target && target[0] === p[0]) return false;
        const dx = tx-fx, dy = ty-fy, ax = Math.abs(dx), ay = Math.abs(dy);
        const type = p[1], isRed = (p[0]==='r');
        switch(type) {
            case 'K': return (tx>=3 && tx<=5 && (isRed ? ty>=7 : ty<=2) && (ax+ay===1));
            case 'A': return (tx>=3 && tx<=5 && (isRed ? ty>=7 : ty<=2) && ax===1 && ay===1);
            case 'E': return ((isRed ? ty>=5 : ty<=4) && ax===2 && ay===2 && !this.getPiece(fx+dx/2, fy+dy/2));
            case 'N': return ((ax===1 && ay===2 && !this.getPiece(fx, fy+(dy>0?1:-1))) || (ax===2 && ay===1 && !this.getPiece(fx+(dx>0?1:-1), fy)));
            case 'R': return ((dx===0 || dy===0) && this.countObs(fx, fy, tx, ty)===0);
            case 'C': { const obs = this.countObs(fx, fy, tx, ty); return (dx===0 || dy===0) && (target ? obs===1 : obs===0); }
            case 'P': {
                const forward = isRed ? -1 : 1; const crossed = isRed ? (fy<=4) : (fy>=5);
                return (dy===forward && dx===0) || (crossed && dy===0 && ax===1);
            }
        }
        return false;
    }
    countObs(x1, y1, x2, y2) {
        let cnt = 0, dx = Math.sign(x2 - x1), dy = Math.sign(y2 - y1);
        let x = x1 + dx, y = y1 + dy;
        if (dx !== 0 && dy !== 0) return -1;
        let safe = 0;
        while(x !== x2 || y !== y2) { 
            if(this.getPiece(x,y)) cnt++; x += dx; y += dy;
            if(safe++ > 20) return 99;
        }
        return cnt;
    }
    isInCheck(c) {
        const k = this.findPiece(c+'K'); if(!k) return true;
        const op = (c==='r'?'b':'r');
        const opK = this.findPiece(op+'K');
        if(opK && k.x===opK.x && this.countObs(k.x, k.y, opK.x, opK.y)===0) return true;
        for(let y=0; y<10; y++) for(let x=0; x<9; x++) {
            const p = this.board[y][x];
            if(p && p[0]===op && this.validate(x,y,k.x,k.y,p)) return true;
        }
        return false;
    }
    findPiece(code) { for(let y=0; y<10; y++) for(let x=0; x<9; x++) if(this.board[y][x]===code) return {x,y}; return null; }

    /* --- NOTATION LOGIC --- */
    
    // WXF (English) for Reader UI
    getWXFNotation(fx, fy, tx, ty, p) {
        const isRed = (p[0] === 'r');
        const startFile = isRed ? (9 - fx) : (fx + 1);
        const endFile = isRed ? (9 - tx) : (tx + 1);
        
        const col = [];
        for(let y=0; y<10; y++) {
            const op = this.getPiece(fx, y);
            if(op === p) col.push(y);
        }
        col.sort((a,b) => isRed ? (a-b) : (b-a));

        let prefix = "";
        let useFile = true;
        const typeChar = p[1] === 'N' ? 'H' : p[1];

        if (col.length > 1) {
            useFile = false;
            const idx = col.indexOf(fy);
            if (col.length === 2) prefix = (idx === 0) ? "+" : "-";
            else prefix = (idx + 1).toString();
        }

        let op = "";
        const dy = ty - fy;
        if (dy === 0) op = ".";
        else if ((isRed && dy < 0) || (!isRed && dy > 0)) op = "+";
        else op = "-";

        let target = "";
        if (['R','C','P','K'].includes(p[1]) && op !== ".") {
            target = Math.abs(dy).toString();
        } else {
            target = endFile.toString();
        }

        return useFile ? `${typeChar}${startFile}${op}${target}` : `${prefix}${typeChar}${op}${target}`;
    }

    // Chinese for Text Export
    getChineseNotation(fx, fy, tx, ty, p) {
        const isRed = (p[0] === 'r');
        const pName = CN_CHARS[p];
        const srcFile = isRed ? (9 - fx) : (fx + 1);
        const dstFile = isRed ? (9 - tx) : (tx + 1);

        const col = [];
        for(let y=0; y<10; y++) { const op = this.getPiece(fx, y); if(op === p) col.push(y); }
        col.sort((a,b) => isRed ? (a-b) : (b-a));

        let fileStr = "";
        if(col.length > 1) {
            const idx = col.indexOf(fy);
            if(col.length === 2) fileStr = (idx === 0) ? CN_CHARS['F'] : CN_CHARS['B'];
            else if(col.length === 3) fileStr = (idx === 0) ? CN_CHARS['F'] : (idx === 1 ? CN_CHARS['M'] : CN_CHARS['B']);
            else fileStr = isRed ? CN_NUMS[idx+1] : CN_DIGITS_FULL[idx+1];
            fileStr += pName;
        } else {
            fileStr = pName + toCNFile(srcFile, isRed);
        }

        let dirStr = "", destStr = "";
        const dy = ty - fy;
        if(dy === 0) {
            dirStr = CN_CHARS['='];
            destStr = toCNNum(dstFile, isRed);
        } else {
            dirStr = ((isRed && dy < 0) || (!isRed && dy > 0)) ? CN_CHARS['+'] : CN_CHARS['-'];
            if(['R','C','P','K'].includes(p[1])) destStr = toCNNum(Math.abs(dy), isRed);
            else destStr = toCNNum(dstFile, isRed);
        }
        return fileStr + dirStr + destStr;
    }
}

/** UI */
const engine = new XiangqiEngine();
let selected = null;
let validMoves = [];
const chars = {'rK':'帥','rA':'仕','rE':'相','rN':'傌','rR':'俥','rC':'炮','rP':'兵','bK':'將','bA':'士','bE':'象','bN':'馬','bR':'車','bC':'炮','bP':'卒'};

function render() {
    const layer = document.getElementById('gridLayer');
    layer.innerHTML = '';
    // 1. Cells
    for(let y=0; y<10; y++) {
        for(let x=0; x<9; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.style.left = (x * 11.11) + '%';
            cell.style.top = (y * 10) + '%';
            cell.onclick = () => onCellClick(x, y);
            layer.appendChild(cell);
        }
    }
    // 2. Markers
    if(engine.history.length) {
        const last = engine.history[engine.history.length-1];
        addMarker(layer, last.fx, last.fy, 'marker last');
        addMarker(layer, last.tx, last.ty, 'marker last');
    }
    if(selected) addMarker(layer, selected.x, selected.y, 'marker selected');
    validMoves.forEach(m => addMarker(layer, m.x, m.y, 'marker valid'));
    // 3. Pieces
    for(let y=0; y<10; y++) {
        for(let x=0; x<9; x++) {
            const p = engine.getPiece(x,y);
            if(p) {
                const div = document.createElement('div');
                div.className = `piece ${p[0]==='r'?'red':'black'}`;
                div.innerText = chars[p];
                div.style.left = (x * 11.11 + 5.55) + '%';
                div.style.top = (y * 10 + 5) + '%';
                layer.appendChild(div);
            }
        }
    }
}
function addMarker(p, x, y, c) {
    const d = document.createElement('div'); d.className = c;
    d.style.left = (x * 11.11 + 5.55) + '%'; d.style.top = (y * 10 + 5) + '%';
    p.appendChild(d);
}
function onCellClick(x, y) {
    const p = engine.getPiece(x, y);
    const myTurn = p && p[0] === engine.turn;
    if (myTurn) {
        selected = {x, y}; validMoves = engine.getValidMoves(x, y);
        render(); return;
    }
    if (selected) {
        if (validMoves.some(m => m.x === x && m.y === y)) {
            const res = engine.move(selected.x, selected.y, x, y);
            if(res.success) {
                selected = null; validMoves = [];
                render(); updateUI();
                if(res.check) { playSound('check'); splash(); }
                else if(res.capture) playSound('capture');
                else playSound('move');
            }
        } else { selected = null; validMoves = []; render(); }
    }
}
function updateUI() {
    document.getElementById('status').innerText = (engine.turn==='r' ? "Red" : "Black") + "'s Turn";
    document.getElementById('status').style.color = (engine.turn==='r' ? "#ff5252" : "#fff");
    const list = document.getElementById('moveHistory');
    list.innerHTML = '';
    for(let i=0; i<engine.history.length; i+=2) {
        const rm = engine.history[i];
        const bm = engine.history[i+1];
        const row = document.createElement('div');
        row.className = 'move-row';
        row.innerHTML = `
            <span style="color:#aaa; width:25px;">${(i/2)+1}.</span>
            <span style="color:#ff5252; flex:1;">${rm ? rm.notation : ''}</span>
            <span style="color:#eee; flex:1; text-align:right;">${bm ? bm.notation : ''}</span>
        `;
        list.appendChild(row);
    }
    list.scrollTop = list.scrollHeight;
}
function splash() {
    const el = document.getElementById('splash');
    el.classList.remove('active'); void el.offsetWidth; el.classList.add('active');
    setTimeout(() => el.classList.remove('active'), 1200);
}

const game = {
    reset: () => { engine.reset(); selected=null; validMoves=[]; render(); updateUI(); playSound('move'); },
    undo: () => { if(engine.undo()) { selected=null; validMoves=[]; render(); updateUI(); playSound('move'); } },
    
    // EXPORT: Custom .xqpro (JSON)
    exportXQPro: () => {
        let coords = ""; engine.history.forEach(m => coords+=`${m.fx}${m.fy}${m.tx}${m.ty}`);
        const data = { type: 'XiangqiMaster_Save', fen: engine.initialFen, moves: coords };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'game.xqpro';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
    },

    // EXPORT: Text Box (Chinese Format)
    exportText: () => {
        let txt = "开始局面: " + engine.initialFen + "\n着法: \n";
        for(let i=0; i<engine.history.length; i+=2) {
            const rm = engine.history[i];
            const bm = engine.history[i+1];
            txt += `${(i/2)+1}. ${rm.cnNotation}`;
            if(bm) txt += ` ${bm.cnNotation}`;
            txt += "\n";
        }
        document.getElementById('ioInput').value = txt;
    },

    loadFile: (e) => {
        const f = e.target.files[0]; if(!f) return;
        const r = new FileReader();
        r.onload = (evt) => game.parse(evt.target.result);
        r.readAsText(f);
    },

    loadFromInput: () => { game.parse(document.getElementById('ioInput').value); },

    parse: (txt) => {
        let fen = engine.initialFen, moveStr = "";
        try {
            // 1. .xqpro JSON
            const json = JSON.parse(txt);
            if(json.type === 'XiangqiMaster_Save') { fen = json.fen; moveStr = json.moves; }
        } catch(e) {
            // 2. DPXQ Parsing
            const f = txt.match(/_fen](.*?)\[/); if(f) fen = f[1];
            const m = txt.match(/_movelist](.*?)\[/); if(m) moveStr = m[1];
            // 3. Raw String
            if(!m && /^\d+$/.test(txt.trim())) moveStr = txt.trim();
        }

        // Replay
        engine.reset(); engine.loadFEN(fen); engine.initialFen = fen;
        for(let i=0; i<moveStr.length; i+=4) {
            const fx=parseInt(moveStr[i]), fy=parseInt(moveStr[i+1]), tx=parseInt(moveStr[i+2]), ty=parseInt(moveStr[i+3]);
            const p = engine.getPiece(fx, fy);
            if(p) {
                const wxf = engine.getWXFNotation(fx, fy, tx, ty, p);
                const cn = engine.getChineseNotation(fx, fy, tx, ty, p);
                const captured = engine.getPiece(tx, ty);
                engine.board[ty][tx] = p; engine.board[fy][fx] = null;
                engine.history.push({fx,fy,tx,ty,captured,p,notation:wxf,cnNotation:cn});
                engine.turn = (engine.turn==='r')?'b':'r';
            }
        }
        selected=null; validMoves=[]; render(); updateUI(); playSound('move');
    }
};

render(); updateUI();
</script>
</body>
</html>
