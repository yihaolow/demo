<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Xiangqi Master Pro - Optimized</title>
    <style>
      /* REVERTED: Simplified CSS for performance and original aesthetic */
      body {
        font-family: sans-serif;
        background: #34495e; /* Simple dark background */
        color: #fff;
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      h1 {
        font-weight: 300;
        margin: 20px 0;
      }

      .main-container {
        display: flex;
        gap: 20px;
        justify-content: center;
        align-items: flex-start;
        flex-wrap: wrap;
        padding-bottom: 50px;
        max-width: 1000px;
      }

      @media (max-width: 800px) {
        .main-container {
          flex-direction: column;
          align-items: center;
        }
        .sidebar {
          width: 90vw;
          max-width: 400px;
        }
        .board-frame {
          max-width: 95vw;
        }
      }

      /* --- BOARD & FLIP STYLES --- */
      .board-frame {
        padding: 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 5px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      }

      .board-wrapper {
        position: relative;
        width: 400px;
        height: 450px;
        background-color: #e6b086;
        border: 1px solid #5d4037;
        user-select: none;

        /* KEPT: Flip Transition */
        transition: transform 0.5s ease-in-out;
        transform-style: preserve-3d;
      }

      /* KEPT: Board Flip */
      .board-wrapper.flipped {
        transform: rotateX(180deg) rotateY(180deg);
      }

      @media (max-width: 450px) {
        .board-wrapper {
          width: 90vw;
          height: 101.25vw;
        }
      }

      svg.board-grid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      line,
      rect,
      path {
        stroke: #5d4037;
        stroke-width: 2;
        fill: none;
        stroke-linecap: square;
      }

      .river-text {
        font-family: "KaiTi", "STKaiti", serif;
        font-size: 32px;
        fill: #5d4037;
        opacity: 0.6;
        text-anchor: middle;
        dominant-baseline: middle;
      }

      /* --- LAYERS --- */
      .interaction-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
      }

      .cell {
        position: absolute;
        width: 11.11%;
        height: 10%;
        cursor: pointer;
        z-index: 15;
      }

      /* Markers */
      .marker {
        position: absolute;
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 5;
        /* REVERTED: Removed slow transition on markers */
        transform-style: preserve-3d;
      }

      .marker.selected {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: rgba(255, 165, 0, 0.4);
        opacity: 0.9;
      }

      .marker.last {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: rgba(60, 100, 180, 0.6);
      }

      .marker.valid {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.3);
      }

      /* --- PIECES --- */
      .piece {
        width: 50px;
        height: 50px; /* Simplified size */
        border-radius: 50%;
        position: absolute;
        transform: translate(-50%, -50%);
        z-index: 20;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: "KaiTi", "STKaiti", serif;
        font-size: 26px;
        font-weight: bold;
        pointer-events: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        /* REVERTED: Simplified transition for fluidity. Only left/top for movement. */
        transition: left 0.2s ease-out, top 0.2s ease-out;
        transform-style: preserve-3d;
      }

      /* KEPT: Flip pieces and markers back right-side-up */
      .board-wrapper.flipped .piece,
      .board-wrapper.flipped .marker {
        transform: translate(-50%, -50%) rotateX(180deg) rotateY(180deg);
      }

      .piece.red {
        background: #fefefe;
        color: #c0392b;
        border: 2px solid #c0392b;
      }
      .piece.black {
        background: #444;
        color: #eee;
        border: 2px solid #999;
      }
      .piece::before {
        content: "";
        position: absolute;
        top: 3px;
        left: 3px;
        right: 3px;
        bottom: 3px;
        border-radius: 50%;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }
      .piece.black::before {
        border-color: rgba(255, 255, 255, 0.15);
      }

      /* --- SPLASH SCREEN (Simplified) --- */
      #splash {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 100;
      }
      #splash.active {
        opacity: 1;
      }

      #splash.capture-subtle {
        background: rgba(0, 0, 0, 0.2);
      }
      #splash.capture-subtle .splash-text {
        font-size: 2.5rem;
        color: #f1c40f;
        padding: 10px 20px;
      }

      .splash-text {
        font-family: "KaiTi", serif;
        font-size: 5rem;
        color: #ff3b30;
        background: rgba(0, 0, 0, 0.8);
        padding: 30px 60px;
        border-radius: 10px;
        text-shadow: 0 0 10px #d32f2f;
        transform: scale(0.5);
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }
      #splash.active .splash-text {
        transform: scale(1);
      }

      /* Sidebar styles */
      .sidebar {
        width: 340px;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }
      .panel {
        background: #2c3e50;
        border: 1px solid #1f2a35;
        border-radius: 5px;
        padding: 15px;
        box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
      }
      .status-box {
        text-align: center;
        font-size: 1.1rem;
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        margin-bottom: 10px;
        font-weight: 600;
      }
      .history-box {
        height: 200px;
        overflow-y: auto;
        font-family: monospace;
        font-size: 13px;
        background: #1f2a35;
        padding: 5px;
        border-radius: 3px;
        margin-bottom: 10px;
      }
      .move-row {
        display: flex;
        justify-content: space-between;
        padding: 3px 6px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }
      textarea {
        width: 100%;
        height: 60px;
        background: #1f2a35;
        border: 1px solid #444;
        color: white;
        border-radius: 3px;
        padding: 5px;
        font-family: monospace;
        resize: none;
        margin-bottom: 5px;
        outline: none;
      }
      .btn-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      button {
        flex: 1;
        padding: 8px;
        background: #555;
        border: none;
        color: white;
        border-radius: 3px;
        cursor: pointer;
        font-weight: 600;
        font-size: 0.8rem;
        transition: background 0.1s;
        touch-action: manipulation;
      }
      button:hover {
        background: #777;
      }
      #file-selector {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>Xiangqi Master Pro</h1>

    <div class="main-container">
      <div class="board-frame">
        <div class="board-wrapper">
          <svg class="board-grid" viewBox="0 0 400 450">
            <rect x="0" y="0" width="400" height="450" stroke-width="4" />
            <line x1="50" y1="0" x2="50" y2="200" />
            <line x1="50" y1="250" x2="50" y2="450" />
            <line x1="100" y1="0" x2="100" y2="200" />
            <line x1="100" y1="250" x2="100" y2="450" />
            <line x1="150" y1="0" x2="150" y2="200" />
            <line x1="150" y1="250" x2="150" y2="450" />
            <line x1="200" y1="0" x2="200" y2="200" />
            <line x1="200" y1="250" x2="200" y2="450" />
            <line x1="250" y1="0" x2="250" y2="200" />
            <line x1="250" y1="250" x2="250" y2="450" />
            <line x1="300" y1="0" x2="300" y2="200" />
            <line x1="300" y1="250" x2="300" y2="450" />
            <line x1="350" y1="0" x2="350" y2="200" />
            <line x1="350" y1="250" x2="350" y2="450" />
            <line x1="0" y1="50" x2="400" y2="50" />
            <line x1="0" y1="100" x2="400" y2="100" />
            <line x1="0" y1="150" x2="400" y2="150" />
            <line x1="0" y1="200" x2="400" y2="200" />
            <line x1="0" y1="250" x2="400" y2="250" />
            <line x1="0" y1="300" x2="400" y2="300" />
            <line x1="0" y1="350" x2="400" y2="350" />
            <line x1="0" y1="400" x2="400" y2="400" />
            <line x1="150" y1="0" x2="250" y2="100" />
            <line x1="250" y1="0" x2="150" y2="100" />
            <line x1="150" y1="350" x2="250" y2="450" />
            <line x1="250" y1="350" x2="150" y2="450" />
            <text x="100" y="225" class="river-text">楚 河</text>
            <text x="300" y="225" class="river-text">漢 界</text>
          </svg>
          <div class="interaction-layer" id="gridLayer"></div>
        </div>
      </div>

      <div class="sidebar">
        <div class="panel">
          <div id="status" class="status-box">Red's Turn</div>
          <div id="moveHistory" class="history-box"></div>
          <div class="btn-row">
            <button style="background: #c0392b" onclick="game.reset()">
              Reset
            </button>
            <button onclick="game.undo()">Undo</button>
            <button onclick="game.flipBoard()" style="background: #4a148c">
              Flip Board
            </button>
          </div>
        </div>

        <div class="panel">
          <div style="font-size: 0.8rem; margin-bottom: 5px; opacity: 0.7">
            Game Data (Text Export)
          </div>
          <textarea
            id="ioInput"
            placeholder="Exported text will appear here..."
          ></textarea>

          <input
            type="file"
            id="file-selector"
            accept=".xqpro,.txt"
            onchange="game.loadFile(event)"
          />

          <div class="btn-row">
            <button
              style="background: #27ae60"
              onclick="document.getElementById('file-selector').click()"
            >
              Load .xqpro
            </button>
            <button onclick="game.exportXQPro()">Save .xqpro</button>
          </div>
          <div class="btn-row" style="margin-top: 8px">
            <button onclick="game.loadFromInput()">Load Text/DPXQ</button>
            <button onclick="game.exportText()">Export Text</button>
          </div>
        </div>
      </div>
    </div>

    <div id="splash"><div class="splash-text"></div></div>

    <script>
      /** AUDIO */
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      function playSound(type) {
        if (audioCtx.state === "suspended") audioCtx.resume();
        const t = audioCtx.currentTime;
        const mkOsc = (freq, type, dur, vol) => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = type;
          osc.frequency.setValueAtTime(freq, t);
          gain.gain.setValueAtTime(vol, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start(t);
          osc.stop(t + dur);
        };
        if (type === "move") {
          mkOsc(200, "sine", 0.15, 0.4);
          mkOsc(50, "square", 0.05, 0.2);
        } else if (type === "capture") {
          mkOsc(300, "triangle", 0.1, 0.5);
          mkOsc(150, "square", 0.1, 0.3);
        } else if (type === "check") {
          mkOsc(800, "triangle", 0.6, 0.3);
        }
      }

      /** CHINESE NOTATION DATA (For Text Export Only) */
      const CN_CHARS = {
        rR: "俥",
        rN: "傌",
        rE: "相",
        rA: "仕",
        rK: "帥",
        rC: "炮",
        rP: "兵",
        bR: "車",
        bN: "馬",
        bE: "象",
        bA: "士",
        bK: "將",
        bC: "炮",
        bP: "卒",
        "+": "进",
        "-": "退",
        "=": "平",
        F: "前",
        M: "中",
        B: "后",
      };
      const CN_NUMS = [
        "零",
        "一",
        "二",
        "三",
        "四",
        "五",
        "六",
        "七",
        "八",
        "九",
      ];
      const CN_DIGITS_FULL = [
        "０",
        "１",
        "２",
        "３",
        "４",
        "5",
        "６",
        "７",
        "８",
        "９",
      ];
      function toCNFile(n, isRed) {
        return isRed ? CN_NUMS[n] : CN_DIGITS_FULL[n];
      }
      function toCNNum(n, isRed) {
        return isRed ? CN_NUMS[n] : CN_DIGITS_FULL[n];
      }

      // Global flip state
      let isFlipped = false;

      class XiangqiEngine {
        constructor() {
          this.reset();
        }
        reset() {
          this.board = Array(10)
            .fill(null)
            .map(() => Array(9).fill(null));
          this.turn = "r";
          this.history = [];
          this.initialFen =
            "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1";
          this.loadFEN(this.initialFen);
        }
        getPiece(x, y) {
          if (x < 0 || x > 8 || y < 0 || y > 9) return null;
          return this.board[y][x];
        }
        loadFEN(fen) {
          this.board = Array(10)
            .fill(null)
            .map(() => Array(9).fill(null));
          const parts = fen.split(" ");
          const rows = parts[0].split("/");
          const map = {
            R: "rR",
            N: "rN",
            B: "rE",
            A: "rA",
            K: "rK",
            C: "rC",
            P: "rP",
            r: "bR",
            n: "bN",
            b: "bE",
            a: "bA",
            k: "bK",
            c: "bC",
            p: "bP",
          };
          for (let y = 0; y < 10; y++) {
            let x = 0;
            const row = rows[y] || "";
            for (let i = 0; i < row.length; i++) {
              const c = row[i];
              if (!isNaN(c)) x += parseInt(c);
              else {
                if (map[c]) this.board[y][x] = map[c];
                x++;
              }
            }
          }
          this.turn = parts[1] === "b" ? "b" : "r";
          if (this.history.length === 0) this.initialFen = fen;
        }
        getFEN() {
          let fen = "";
          const map = {
            rR: "R",
            rN: "N",
            rE: "B",
            rA: "A",
            rK: "K",
            rC: "C",
            rP: "P",
            bR: "r",
            bN: "n",
            bE: "b",
            bA: "a",
            bK: "k",
            bC: "c",
            bP: "p",
          };
          for (let y = 0; y < 10; y++) {
            let empty = 0;
            for (let x = 0; x < 9; x++) {
              const p = this.board[y][x];
              if (!p) empty++;
              else {
                if (empty > 0) {
                  fen += empty;
                  empty = 0;
                }
                fen += map[p];
              }
            }
            if (empty > 0) fen += empty;
            if (y < 9) fen += "/";
          }
          return fen + " " + (this.turn === "r" ? "w" : "b") + " - - 0 1";
        }

        // --- CORE MOVEMENT/VALIDATION (Unchanged Logic) ---
        move(fx, fy, tx, ty) {
          const p = this.getPiece(fx, fy);
          if (!p || p[0] !== this.turn) return { success: false };

          const tempBoard = JSON.parse(JSON.stringify(this.board));
          const captured = tempBoard[ty][tx];

          if (!this.validate(fx, fy, tx, ty, p, tempBoard))
            return { success: false };

          tempBoard[ty][tx] = p;
          tempBoard[fy][fx] = null;

          if (this.isInCheck(this.turn, tempBoard)) {
            return { success: false, reason: "Self check" };
          }
          if (this.isFlyingGeneral(tempBoard)) {
            return { success: false, reason: "Flying General" };
          }

          this.board = tempBoard;

          const wxf = this.getWXFNotation(fx, fy, tx, ty, p);
          const cn = this.getChineseNotation(fx, fy, tx, ty, p);

          this.history.push({
            fx,
            fy,
            tx,
            ty,
            captured,
            p,
            notation: wxf,
            cnNotation: cn,
          });
          this.turn = this.turn === "r" ? "b" : "r";
          return {
            success: true,
            capture: !!captured,
            check: this.isInCheck(this.turn),
          };
        }

        validate(fx, fy, tx, ty, p, board = this.board) {
          if (fx === tx && fy === ty) return false;
          const target = this.getPieceFromBoard(tx, ty, board);
          if (target && target[0] === p[0]) return false;
          const dx = tx - fx,
            dy = ty - fy,
            ax = Math.abs(dx),
            ay = Math.abs(dy);
          const type = p[1],
            isRed = p[0] === "r";
          const getP = (x, y) => this.getPieceFromBoard(x, y, board);

          switch (type) {
            case "K":
              return (
                tx >= 3 &&
                tx <= 5 &&
                (isRed ? ty >= 7 : ty <= 2) &&
                ax + ay === 1
              );
            case "A":
              return (
                tx >= 3 &&
                tx <= 5 &&
                (isRed ? ty >= 7 : ty <= 2) &&
                ax === 1 &&
                ay === 1
              );
            case "E":
              return (
                (isRed ? ty >= 5 : ty <= 4) &&
                ax === 2 &&
                ay === 2 &&
                !getP(fx + dx / 2, fy + dy / 2)
              );
            case "N":
              return (
                (ax === 1 && ay === 2 && !getP(fx, fy + Math.sign(dy))) ||
                (ax === 2 && ay === 1 && !getP(fx + Math.sign(dx), fy))
              );
            case "R":
              return (
                (dx === 0 || dy === 0) &&
                this.countObs(fx, fy, tx, ty, board) === 0
              );
            case "C": {
              const obs = this.countObs(fx, fy, tx, ty, board);
              return (dx === 0 || dy === 0) && (target ? obs === 1 : obs === 0);
            }
            case "P": {
              const forward = isRed ? -1 : 1;
              const crossed = isRed ? fy <= 4 : fy >= 5;
              return (
                (dy === forward && dx === 0) ||
                (crossed && dy === 0 && ax === 1 && ay === 0)
              );
            }
          }
          return false;
        }

        getPieceFromBoard(x, y, board) {
          if (x < 0 || x > 8 || y < 0 || y > 9) return null;
          return board[y][x];
        }

        countObs(x1, y1, x2, y2, board = this.board) {
          let cnt = 0,
            dx = Math.sign(x2 - x1),
            dy = Math.sign(y2 - y1);
          let x = x1 + dx,
            y = y1 + dy;
          if (dx !== 0 && dy !== 0) return -1;
          while (x !== x2 || y !== y2) {
            if (this.getPieceFromBoard(x, y, board)) cnt++;
            x += dx;
            y += dy;
          }
          return cnt;
        }

        findPiece(code, board = this.board) {
          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++)
              if (board[y][x] === code) return { x, y };
          return null;
        }

        isFlyingGeneral(board = this.board) {
          const k = this.findPiece("rK", board);
          const opK = this.findPiece("bK", board);
          if (!k || !opK) return false;
          if (k.x !== opK.x) return false;
          if (this.countObs(k.x, k.y, opK.x, opK.y, board) === 0) return true;
          return false;
        }

        isInCheck(c, board = this.board) {
          const k = this.findPiece(c + "K", board);
          if (!k) return false;
          const op = c === "r" ? "b" : "r";

          const opK = this.findPiece(op + "K", board);
          if (
            opK &&
            k.x === opK.x &&
            this.countObs(k.x, k.y, opK.x, opK.y, board) === 0
          )
            return true;

          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++) {
              const p = board[y][x];
              if (p && p[0] === op && this.validate(x, y, k.x, k.y, p, board))
                return true;
            }
          return false;
        }

        getValidMoves(fx, fy) {
          const p = this.getPiece(fx, fy);
          if (!p || p[0] !== this.turn) return [];
          const moves = [];
          for (let ty = 0; ty < 10; ty++) {
            for (let tx = 0; tx < 9; tx++) {
              if (this.validate(fx, fy, tx, ty, p)) {
                const tempBoard = JSON.parse(JSON.stringify(this.board));
                tempBoard[ty][tx] = p;
                tempBoard[fy][fx] = null;

                if (
                  !this.isInCheck(p[0], tempBoard) &&
                  !this.isFlyingGeneral(tempBoard)
                ) {
                  moves.push({ x: tx, y: ty });
                }
              }
            }
          }
          return moves;
        }

        // --- UTILS ---
        undo() {
          if (!this.history.length) return false;
          const last = this.history.pop();
          this.board[last.fy][last.fx] = last.p;
          this.board[last.ty][last.tx] = last.captured;
          this.turn = last.p[0];
          return true;
        }

        // Simplified Notation Logic
        getWXFNotation(fx, fy, tx, ty, p) {
          return `${p[1]}${fx + 1}-${tx + 1}`;
        }
        getChineseNotation(fx, fy, tx, ty, p) {
          return `${CN_CHARS[p]}${fx + 1}${CN_CHARS["="]}${tx + 1}`;
        }
      }

      /** UI */
      const engine = new XiangqiEngine();
      let selected = null;
      let validMoves = [];
      const chars = {
        rK: "帥",
        rA: "仕",
        rE: "相",
        rN: "傌",
        rR: "俥",
        rC: "炮",
        rP: "兵",
        bK: "將",
        bA: "士",
        bE: "象",
        bN: "馬",
        bR: "車",
        bC: "炮",
        bP: "卒",
      };

      function render() {
        const layer = document.getElementById("gridLayer");
        layer.innerHTML = "";

        // Grid unit in percentage
        const X_UNIT = 100 / 8; // 12.5% (8 segments, 9 points)
        const Y_UNIT = 100 / 9; // 11.11...% (9 segments, 10 points)

        // 1. Cells (Invisible layer for clicking)
        for (let y = 0; y < 10; y++) {
          for (let x = 0; x < 9; x++) {
            const cell = document.createElement("div");
            cell.className = "cell";
            cell.style.left = x * 11.11 + "%";
            cell.style.top = y * 10 + "%";
            cell.onclick = () => onCellClick(x, y);
            layer.appendChild(cell);
          }
        }

        // 2. Markers
        if (engine.history.length) {
          const last = engine.history[engine.history.length - 1];
          addMarker(layer, last.fx, last.fy, "marker last", X_UNIT, Y_UNIT);
          addMarker(layer, last.tx, last.ty, "marker last", X_UNIT, Y_UNIT);
        }
        if (selected)
          addMarker(
            layer,
            selected.x,
            selected.y,
            "marker selected",
            X_UNIT,
            Y_UNIT
          );
        validMoves.forEach((m) =>
          addMarker(layer, m.x, m.y, "marker valid", X_UNIT, Y_UNIT)
        );

        // 3. Pieces
        for (let y = 0; y < 10; y++) {
          for (let x = 0; x < 9; x++) {
            const p = engine.getPiece(x, y);
            if (p) {
              const div = document.createElement("div");
              div.className = `piece ${p[0] === "r" ? "red" : "black"}`;
              div.innerText = chars[p];

              // REVERTED & CORRECTED ALIGNMENT LOGIC:
              // Uses X_UNIT and Y_UNIT derived from the number of segments (8 and 9 respectively).
              div.style.left = x * X_UNIT + "%";
              div.style.top = y * Y_UNIT + "%";

              layer.appendChild(div);
            }
          }
        }
      }

      function addMarker(p, x, y, c, X_UNIT, Y_UNIT) {
        const d = document.createElement("div");
        d.className = c;

        // REVERTED & CORRECTED ALIGNMENT LOGIC for markers
        d.style.left = x * X_UNIT + "%";
        d.style.top = y * Y_UNIT + "%";

        p.appendChild(d);
      }

      function onCellClick(x, y) {
        const p = engine.getPiece(x, y);
        const myTurn = p && p[0] === engine.turn;

        if (myTurn) {
          selected = { x, y };
          validMoves = engine.getValidMoves(x, y);
          render();
          return;
        }

        if (selected) {
          const canMove = validMoves.some((m) => m.x === x && m.y === y);
          if (canMove) {
            const res = engine.move(selected.x, selected.y, x, y);
            if (res.success) {
              selected = null;
              validMoves = [];
              render();
              updateUI();
              if (res.check) {
                playSound("check");
                splash("check");
              } else if (res.capture) {
                playSound("capture");
                splash("capture");
              } else playSound("move");
            } else if (res.reason) {
              alert(
                `Illegal Move: ${
                  res.reason === "Flying General"
                    ? "Violates the Flying General (Kings Facing) rule!"
                    : "Results in King in Check!"
                }`
              );
            }
          } else {
            // Clicks a non-valid target or an empty square after selecting a piece. Deselect.
            selected = null;
            validMoves = [];
            render();
          }
        }
      }

      function updateUI() {
        document.getElementById("status").innerText =
          (engine.turn === "r" ? "Red (帥)" : "Black (將)") + "'s Turn";
        document.getElementById("status").style.color =
          engine.turn === "r" ? "#ff5252" : "#eee";
        const list = document.getElementById("moveHistory");
        list.innerHTML = "";
        for (let i = 0; i < engine.history.length; i += 2) {
          const rm = engine.history[i];
          const bm = engine.history[i + 1];
          const row = document.createElement("div");
          row.className = "move-row";
          row.innerHTML = `
            <span style="color:#aaa; width:25px;">${i / 2 + 1}.</span>
            <span style="color:#ff5252; flex:1;">${rm ? rm.notation : ""}</span>
            <span style="color:#eee; flex:1; text-align:right;">${
              bm ? bm.notation : ""
            }</span>
        `;
          list.appendChild(row);
        }
        list.scrollTop = list.scrollHeight;
      }

      function splash(type) {
        const el = document.getElementById("splash");
        const textEl = el.querySelector(".splash-text");

        el.classList.remove("active", "capture-subtle");
        textEl.classList.remove("capture-subtle");

        let text = "";
        let duration = 1200;

        if (type === "capture") {
          text = "吃!";
          el.classList.add("capture-subtle");
          textEl.classList.add("capture-subtle");
          duration = 800;
        } else if (type === "check") {
          text = "將軍";
        }

        textEl.innerText = text;

        void el.offsetWidth;
        el.classList.add("active");

        setTimeout(() => el.classList.remove("active"), duration);
      }

      const game = {
        reset: () => {
          engine.reset();
          selected = null;
          validMoves = [];
          render();
          updateUI();
          playSound("move");
          isFlipped = false;
          document.querySelector(".board-wrapper").classList.remove("flipped");
        },
        undo: () => {
          if (engine.undo()) {
            selected = null;
            validMoves = [];
            render();
            updateUI();
            playSound("move");
          }
        },

        // KEPT: Flip Board function
        flipBoard: () => {
          isFlipped = !isFlipped;
          const wrapper = document.querySelector(".board-wrapper");
          if (isFlipped) {
            wrapper.classList.add("flipped");
          } else {
            wrapper.classList.remove("flipped");
          }
        },

        exportXQPro: () => {
          let coords = "";
          engine.history.forEach(
            (m) => (coords += `${m.fx}${m.fy}${m.tx}${m.ty}`)
          );
          const data = {
            type: "XiangqiMaster_Save",
            fen: engine.initialFen,
            moves: coords,
          };
          const blob = new Blob([JSON.stringify(data)], {
            type: "application/json",
          });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "game.xqpro";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        },

        exportText: () => {
          let txt = "开始局面: " + engine.initialFen + "\n着法: \n";
          for (let i = 0; i < engine.history.length; i += 2) {
            const rm = engine.history[i];
            const bm = engine.history[i + 1];
            txt += `${i / 2 + 1}. ${rm.cnNotation}`;
            if (bm) txt += ` ${bm.cnNotation}`;
            txt += "\n";
          }
          document.getElementById("ioInput").value = txt;
        },

        loadFile: (e) => {
          const f = e.target.files[0];
          if (!f) return;
          const r = new FileReader();
          r.onload = (evt) => game.parse(evt.target.result);
          r.readAsText(f);
        },

        loadFromInput: () => {
          game.parse(document.getElementById("ioInput").value);
        },

        parse: (txt) => {
          let fen = engine.initialFen,
            moveStr = "";
          try {
            const json = JSON.parse(txt);
            if (json.type === "XiangqiMaster_Save") {
              fen = json.fen;
              moveStr = json.moves;
            }
          } catch (e) {
            const f = txt.match(/开始局面: (.*?)\n/);
            if (f) fen = f[1];
            const m = txt.match(/着法: (.*?)\n/);
            if (m) moveStr = m[1];
            if (!m && /^\d+$/.test(txt.trim())) moveStr = txt.trim();
          }

          engine.reset();
          engine.loadFEN(fen);
          engine.initialFen = fen;
          for (let i = 0; i < moveStr.length; i += 4) {
            const fx = parseInt(moveStr[i]),
              fy = parseInt(moveStr[i + 1]),
              tx = parseInt(moveStr[i + 2]),
              ty = parseInt(moveStr[i + 3]);
            const p = engine.getPiece(fx, fy);
            if (p) {
              const wxf = engine.getWXFNotation(fx, fy, tx, ty, p);
              const cn = engine.getChineseNotation(fx, fy, tx, ty, p);
              const captured = engine.getPiece(tx, ty);

              engine.board[ty][tx] = p;
              engine.board[fy][fx] = null;
              engine.history.push({
                fx,
                fy,
                tx,
                ty,
                captured,
                p,
                notation: wxf,
                cnNotation: cn,
              });
              engine.turn = engine.turn === "r" ? "b" : "r";
            }
          }
          selected = null;
          validMoves = [];
          render();
          updateUI();
          playSound("move");
        },
      };

      render();
      updateUI();
    </script>
  </body>
</html>
