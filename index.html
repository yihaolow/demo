<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Xiangqi Master: Mobile</title>
    <style>
      :root {
        --bg-grad: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
        --board-bg: #eecfa1;
        --line-color: #5d4037;
        --glass: rgba(255, 255, 255, 0.08);
        --glass-border: rgba(255, 255, 255, 0.1);
        --highlight: rgba(255, 215, 0, 0.4);
        --selected: rgba(0, 255, 0, 0.5);
        --red: #d63031;
        --black: #2d3436;
        --tab-active: #2980b9;
      }

      body {
        margin: 0;
        background: var(--bg-grad);
        color: #ddd;
        font-family: "Microsoft YaHei", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        /* Mobile scroll fix */
        height: 100dvh;
        overflow: hidden;
      }

      .container {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        max-width: 600px; /* Constrain width on tablets */
        padding: 10px;
        box-sizing: border-box;
        gap: 10px;
      }

      /* --- RESPONSIVE BOARD --- */
      .board-frame {
        width: 100%;
        /* Maintain 9:10 aspect ratio for Xiangqi board */
        aspect-ratio: 450/500;
        position: relative;
        background: var(--board-bg);
        border-radius: 4px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
      }

      /* Inner wrapper maintains coordinate system relative to container size */
      .board-inner {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        /* Grid system logic (9 cols x 10 rows) */
      }

      /* SVG Scaling */
      svg.grid {
        width: 100%;
        height: 100%;
        display: block;
        pointer-events: none;
      }
      .line {
        stroke: var(--line-color);
        stroke-width: 2;
        fill: none;
        vector-effect: non-scaling-stroke;
      }
      .border {
        stroke: var(--line-color);
        stroke-width: 4;
        fill: none;
        vector-effect: non-scaling-stroke;
      }
      .river-text {
        font-family: "KaiTi", serif;
        font-size: 34px;
        fill: var(--line-color);
        opacity: 0.8;
        text-anchor: middle;
        dominant-baseline: middle;
        font-weight: bold;
      }

      /* Layers */
      .layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      .click-mask {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 100;
        cursor: pointer;
        -webkit-tap-highlight-color: transparent;
      }

      /* PIECES - Percent based positioning for perfect alignment */
      .piece {
        width: 11.11%; /* 1/9th of width */
        height: 10%; /* 1/10th of height */
        position: absolute;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
        transition: top 0.15s, left 0.15s;
      }

      /* The visual circle inside the grid cell */
      .piece::after {
        content: attr(data-char);
        width: 85%;
        height: 85%;
        background: #fdf5e6;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: "KaiTi", serif;
        font-weight: bold;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4),
          inset 0 2px 5px rgba(255, 255, 255, 0.9);
        font-size: clamp(16px, 5vw, 28px); /* Responsive font size */
      }
      .piece.red::after {
        color: var(--red);
        border: 2px solid #c0392b;
      }
      .piece.black::after {
        color: var(--black);
        border: 2px solid #333;
      }

      /* MARKERS */
      .marker {
        position: absolute;
        width: 11.11%;
        height: 10%;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .last::after {
        content: "";
        width: 90%;
        height: 90%;
        background: var(--highlight);
        border-radius: 8px;
      }
      .select::after {
        content: "";
        width: 90%;
        height: 90%;
        background: var(--selected);
        border-radius: 50%;
        box-shadow: 0 0 10px var(--selected);
      }
      .dot::after {
        content: "";
        width: 25%;
        height: 25%;
        background: rgba(0, 180, 0, 0.8);
        border-radius: 50%;
      }

      /* --- TABS & CONTROLS --- */
      .ui-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: var(--glass);
        border: 1px solid var(--glass-border);
        border-radius: 8px;
        overflow: hidden;
      }

      .tabs {
        display: flex;
        border-bottom: 1px solid var(--glass-border);
      }
      .tab {
        flex: 1;
        padding: 10px;
        text-align: center;
        cursor: pointer;
        background: rgba(0, 0, 0, 0.2);
        transition: 0.2s;
        font-weight: bold;
      }
      .tab.active {
        background: var(--tab-active);
        color: white;
      }

      .tab-content {
        flex: 1;
        display: none;
        flex-direction: column;
        padding: 10px;
        overflow: hidden;
      }
      .tab-content.active {
        display: flex;
      }

      /* PLAYBACK BAR */
      .playback-bar {
        display: flex;
        gap: 5px;
        margin-bottom: 10px;
      }
      .pb-btn {
        flex: 1;
        padding: 10px 0;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
      }
      .pb-btn:active {
        background: rgba(255, 255, 255, 0.3);
      }

      .status {
        text-align: center;
        margin-bottom: 5px;
        font-weight: bold;
        color: #ff6b6b;
        font-size: 14px;
      }

      .history {
        flex: 1;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        overflow-y: auto;
        padding: 5px;
        font-family: monospace;
        font-size: 13px;
      }
      .row {
        display: flex;
        padding: 4px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }
      .row.current {
        background: rgba(255, 215, 0, 0.2);
        border-left: 3px solid gold;
      }
      .row span {
        flex: 1;
        cursor: pointer;
      }

      /* TOOLS TAB */
      .tool-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      .btn {
        padding: 12px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        cursor: pointer;
        font-weight: bold;
      }
      .btn-norm {
        background: rgba(255, 255, 255, 0.1);
      }
      .btn-red {
        background: #c0392b;
        border: none;
      }
      .btn-green {
        background: #27ae60;
        border: none;
      }
      textarea {
        width: 100%;
        height: 80px;
        background: rgba(0, 0, 0, 0.3);
        color: white;
        border: 1px solid #555;
        resize: none;
        margin-bottom: 10px;
        box-sizing: border-box;
      }

      #splash {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        font-size: 4rem;
        font-family: "KaiTi";
        font-weight: 900;
        color: #ff4757;
        text-shadow: 0 5px 20px black;
        pointer-events: none;
        z-index: 200;
        opacity: 0;
        -webkit-text-stroke: 2px white;
        white-space: nowrap;
      }
      .pop {
        animation: popAnim 1.2s ease-out forwards;
      }
      @keyframes popAnim {
        0% {
          transform: translate(-50%, -50%) scale(0.5);
          opacity: 0;
        }
        20% {
          transform: translate(-50%, -50%) scale(1.2);
          opacity: 1;
        }
        100% {
          transform: translate(-50%, -50%) scale(1);
          opacity: 0;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="board-frame" id="boardFrame">
        <div class="board-inner">
          <svg class="grid" viewBox="0 0 450 500" preserveAspectRatio="none">
            <rect x="25" y="25" width="400" height="450" class="border" />
            <line x1="25" y1="75" x2="425" y2="75" class="line" />
            <line x1="25" y1="125" x2="425" y2="125" class="line" />
            <line x1="25" y1="175" x2="425" y2="175" class="line" />
            <line x1="25" y1="225" x2="425" y2="225" class="line" />
            <line x1="25" y1="275" x2="425" y2="275" class="line" />
            <line x1="25" y1="325" x2="425" y2="325" class="line" />
            <line x1="25" y1="375" x2="425" y2="375" class="line" />
            <line x1="25" y1="425" x2="425" y2="425" class="line" />
            <line x1="225" y1="25" x2="225" y2="225" class="line" />
            <line x1="225" y1="275" x2="225" y2="475" class="line" />
            <line x1="75" y1="25" x2="75" y2="225" class="line" />
            <line x1="75" y1="275" x2="75" y2="475" class="line" />
            <line x1="125" y1="25" x2="125" y2="225" class="line" />
            <line x1="125" y1="275" x2="125" y2="475" class="line" />
            <line x1="175" y1="25" x2="175" y2="225" class="line" />
            <line x1="175" y1="275" x2="175" y2="475" class="line" />
            <line x1="275" y1="25" x2="275" y2="225" class="line" />
            <line x1="275" y1="275" x2="275" y2="475" class="line" />
            <line x1="325" y1="25" x2="325" y2="225" class="line" />
            <line x1="325" y1="275" x2="325" y2="475" class="line" />
            <line x1="375" y1="25" x2="375" y2="225" class="line" />
            <line x1="375" y1="275" x2="375" y2="475" class="line" />
            <line x1="175" y1="25" x2="275" y2="125" class="line" />
            <line x1="275" y1="25" x2="175" y2="125" class="line" />
            <line x1="175" y1="375" x2="275" y2="475" class="line" />
            <line x1="275" y1="375" x2="175" y2="475" class="line" />

            <text x="110" y="250" class="river-text">楚 河</text>
            <text x="340" y="250" class="river-text">漢 界</text>
          </svg>
          <div id="markerLayer" class="layer"></div>
          <div id="pieceLayer" class="layer"></div>
          <div class="click-mask" onclick="ui.click(event)"></div>
          <div id="splash">將 軍</div>
        </div>
      </div>

      <div class="ui-panel">
        <div class="tabs">
          <div class="tab active" onclick="ui.switchTab('game')">Game</div>
          <div class="tab" onclick="ui.switchTab('tools')">Tools</div>
        </div>

        <div id="tab-game" class="tab-content active">
          <div id="status" class="status">Red to Move</div>
          <div class="playback-bar">
            <button class="pb-btn" onclick="game.goto(0)">|&lt;</button>
            <button class="pb-btn" onclick="game.step(-1)">&lt;</button>
            <button class="pb-btn" id="playBtn" onclick="game.togglePlay()">
              ▶
            </button>
            <button class="pb-btn" onclick="game.step(1)">&gt;</button>
            <button class="pb-btn" onclick="game.goto(9999)">&gt;|</button>
          </div>
          <div id="history" class="history"></div>
        </div>

        <div id="tab-tools" class="tab-content">
          <div class="tool-grid">
            <button class="btn btn-red" onclick="game.newGame()">
              New Game
            </button>
            <button class="btn btn-norm" onclick="game.undo()">Undo</button>
            <button class="btn btn-norm" onclick="ui.doFlip()">
              Flip View
            </button>
            <button class="btn btn-norm" onclick="ui.doReflect()">
              Reflect
            </button>
          </div>
          <hr
            style="
              border: 0;
              border-top: 1px solid rgba(255, 255, 255, 0.1);
              margin: 10px 0;
            "
          />
          <textarea id="fenBox" placeholder="Paste FEN/DhtmlXQ..."></textarea>
          <div class="tool-grid">
            <button class="btn btn-norm" onclick="game.load()">Load</button>
            <button class="btn btn-green" onclick="game.export()">
              Export
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      const sfx = {
        play(f, t, g = 0.3, d = 0.1) {
          const c = new (window.AudioContext || window.webkitAudioContext)();
          const o = c.createOscillator();
          const gn = c.createGain();
          o.type = t;
          o.frequency.setValueAtTime(f, c.currentTime);
          gn.gain.setValueAtTime(g, c.currentTime);
          gn.gain.exponentialRampToValueAtTime(0.01, c.currentTime + d);
          o.connect(gn);
          gn.connect(c.destination);
          o.start();
          o.stop(c.currentTime + d);
        },
      };

      const CN_NUMS = [
        "",
        "一",
        "二",
        "三",
        "四",
        "五",
        "六",
        "七",
        "八",
        "九",
      ];
      const CN_DIGITS = [
        "",
        "１",
        "２",
        "３",
        "４",
        "５",
        "６",
        "７",
        "８",
        "９",
      ];
      const CN_PIECES = {
        rK: "帥",
        rA: "仕",
        rE: "相",
        rN: "傌",
        rR: "俥",
        rC: "炮",
        rP: "兵",
        bK: "将",
        bA: "士",
        bE: "象",
        bN: "馬",
        bR: "車",
        bC: "砲",
        bP: "卒",
        K: "帥",
        A: "仕",
        E: "相",
        N: "傌",
        R: "俥",
        C: "炮",
        P: "兵",
        k: "将",
        a: "士",
        e: "象",
        n: "馬",
        r: "車",
        c: "砲",
        p: "卒",
      };
      const CN_DIR = { "+": "进", "-": "退", "=": "平" };

      class Engine {
        constructor() {
          this.reset();
        }
        reset() {
          this.board = Array(10)
            .fill(null)
            .map(() => Array(9).fill(null));
          const start = [
            ["bR", "bN", "bE", "bA", "bK", "bA", "bE", "bN", "bR"],
            [null, null, null, null, null, null, null, null, null],
            [null, "bC", null, null, null, null, null, "bC", null],
            ["bP", null, "bP", null, "bP", null, "bP", null, "bP"],
            [null, null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null, null],
            ["rP", null, "rP", null, "rP", null, "rP", null, "rP"],
            [null, "rC", null, null, null, null, null, "rC", null],
            [null, null, null, null, null, null, null, null, null],
            ["rR", "rN", "rE", "rA", "rK", "rA", "rE", "rN", "rR"],
          ];
          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++) this.board[y][x] = start[y][x];
          this.turn = "r";
          this.history = [];
          this.idx = 0;
        }
        getPiece(x, y) {
          if (x < 0 || x > 8 || y < 0 || y > 9) return null;
          return this.board[y][x];
        }
        validate(fx, fy, tx, ty, p) {
          if (fx === tx && fy === ty) return false;
          const tgt = this.getPiece(tx, ty);
          if (tgt && tgt[0] === p[0]) return false;
          const dx = tx - fx,
            dy = ty - fy,
            adx = Math.abs(dx),
            ady = Math.abs(dy);
          const type = p[1],
            red = p[0] === "r";
          switch (type) {
            case "K":
              return (
                tx >= 3 &&
                tx <= 5 &&
                (red ? ty >= 7 : ty <= 2) &&
                adx + ady === 1
              );
            case "A":
              return (
                tx >= 3 &&
                tx <= 5 &&
                (red ? ty >= 7 : ty <= 2) &&
                adx === 1 &&
                ady === 1
              );
            case "E":
              return (
                (red ? ty >= 5 : ty <= 4) &&
                adx === 2 &&
                ady === 2 &&
                !this.getPiece(fx + dx / 2, fy + dy / 2)
              );
            case "N":
              if (adx === 1 && ady === 2)
                return !this.getPiece(fx, fy + (dy > 0 ? 1 : -1));
              if (adx === 2 && ady === 1)
                return !this.getPiece(fx + (dx > 0 ? 1 : -1), fy);
              return false;
            case "R":
              return (dx === 0 || dy === 0) && this.count(fx, fy, tx, ty) === 0;
            case "C":
              const c = this.count(fx, fy, tx, ty);
              return (dx === 0 || dy === 0) && (tgt ? c === 1 : c === 0);
            case "P":
              const fwd = red ? -1 : 1;
              const cross = red ? fy <= 4 : fy >= 5;
              return (
                (dy === fwd && dx === 0) || (cross && dy === 0 && adx === 1)
              );
          }
          return false;
        }
        count(x1, y1, x2, y2) {
          let c = 0,
            dx = Math.sign(x2 - x1),
            dy = Math.sign(y2 - y1),
            x = x1 + dx,
            y = y1 + dy,
            safe = 0;
          while ((x !== x2 || y !== y2) && safe++ < 20) {
            if (this.getPiece(x, y)) c++;
            x += dx;
            y += dy;
          }
          return c;
        }
        inCheck(turn) {
          let k = null,
            opp = turn === "r" ? "b" : "r";
          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++)
              if (this.board[y][x] === turn + "K") k = { x, y };
          if (!k) return true;
          let ok = null;
          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++)
              if (this.board[y][x] === opp + "K") ok = { x, y };
          if (ok && k.x === ok.x && this.count(k.x, k.y, ok.x, ok.y) === 0)
            return true;
          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++) {
              let p = this.board[y][x];
              if (p && p[0] === opp && this.validate(x, y, k.x, k.y, p))
                return true;
            }
          return false;
        }
        getLegalMoves() {
          let moves = [],
            turn = this.turn;
          for (let fy = 0; fy < 10; fy++)
            for (let fx = 0; fx < 9; fx++) {
              let p = this.board[fy][fx];
              if (p && p[0] === turn) {
                for (let ty = 0; ty < 10; ty++)
                  for (let tx = 0; tx < 9; tx++) {
                    if (this.validate(fx, fy, tx, ty, p)) {
                      let cap = this.board[ty][tx];
                      this.board[ty][tx] = p;
                      this.board[fy][fx] = null;
                      if (!this.inCheck(turn))
                        moves.push({ fx, fy, tx, ty, p, cap });
                      this.board[fy][fx] = p;
                      this.board[ty][tx] = cap;
                    }
                  }
              }
            }
          return moves;
        }
        move(fx, fy, tx, ty) {
          if (this.idx !== this.history.length) return false;
          let p = this.board[fy][fx];
          if (!p || p[0] !== this.turn) return false;
          let cap = this.board[ty][tx];
          if (!this.validate(fx, fy, tx, ty, p)) return false;
          this.board[ty][tx] = p;
          this.board[fy][fx] = null;
          if (this.inCheck(this.turn)) {
            this.board[fy][fx] = p;
            this.board[ty][tx] = cap;
            return false;
          }
          let mvStr = `${fx}${fy}${tx}${ty}`;
          this.history.push({ fx, fy, tx, ty, p, cap, mv: mvStr });
          this.idx++;
          this.turn = this.turn === "r" ? "b" : "r";
          return cap;
        }
      }

      /* --- UI --- */
      const ui = {
        flip: false,
        reflect: false,
        sel: null,

        init() {
          this.render();
          this.updateInfo();
        },

        switchTab(t) {
          document
            .querySelectorAll(".tab")
            .forEach((e) => e.classList.remove("active"));
          document
            .querySelectorAll(".tab-content")
            .forEach((e) => e.classList.remove("active"));
          event.target.classList.add("active");
          document.getElementById("tab-" + t).classList.add("active");
        },

        doFlip() {
          this.flip = !this.flip;
          this.render();
        },
        doReflect() {
          this.reflect = !this.reflect;
          this.render();
          this.updateInfo();
        },

        // RESPONSIVE PERCENTAGE COORDINATES
        toPx(x, y) {
          let rx = this.reflect ? 8 - x : x;
          if (this.flip) {
            rx = 8 - rx;
            ry = 9 - y;
          } else {
            ry = y;
          }
          return { left: rx * 11.11, top: ry * 10 };
        },

        toLog(cx, cy) {
          const rect = document
            .getElementById("boardFrame")
            .getBoundingClientRect();
          // Since we use 100% width/height, calc based on rect
          let x = Math.floor((cx - rect.left) / (rect.width / 9));
          let y = Math.floor((cy - rect.top) / (rect.height / 10));

          if (x < 0 || x > 8 || y < 0 || y > 9) return null;
          if (this.flip) {
            x = 8 - x;
            y = 9 - y;
          }
          if (this.reflect) x = 8 - x;
          return { x, y };
        },

        click(e) {
          if (game.eng.idx !== game.eng.history.length || game.isGameOver)
            return;
          const c = this.toLog(e.clientX, e.clientY);
          if (!c) return;
          const p = game.eng.getPiece(c.x, c.y);

          const handleMove = () => {
            const cap = game.eng.move(this.sel.x, this.sel.y, c.x, c.y);
            if (cap !== false) {
              if (cap) sfx.play(200, "triangle", 0.2, 0.1);
              else sfx.play(300, "square");
              this.sel = null;
              requestAnimationFrame(() => {
                this.render();
                this.updateInfo();
                game.checkGameOver();
              });
            } else if (p && p[0] === game.eng.turn) {
              this.sel = c;
              sfx.play(150, "sine");
              requestAnimationFrame(() => this.render());
            } else {
              this.sel = null;
              requestAnimationFrame(() => this.render());
            }
          };
          if (this.sel) handleMove();
          else if (p && p[0] === game.eng.turn) {
            this.sel = c;
            sfx.play(150, "sine");
            requestAnimationFrame(() => this.render());
          }
        },

        render() {
          const pL = document.getElementById("pieceLayer");
          const mL = document.getElementById("markerLayer");
          pL.innerHTML = "";
          mL.innerHTML = "";

          let board = game.eng.board;
          if (game.eng.idx < game.eng.history.length) {
            let tmp = new Engine();
            if (game.startFen) game.loadFenTo(game.startFen, tmp);
            for (let i = 0; i < game.eng.idx; i++) {
              let m = game.eng.history[i];
              tmp.board[m.ty][m.tx] = tmp.board[m.fy][m.fx];
              tmp.board[m.fy][m.fx] = null;
            }
            board = tmp.board;
          }

          for (let y = 0; y < 10; y++)
            for (let x = 0; x < 9; x++) {
              let p = board[y][x];
              let pos = this.toPx(x, y);

              let last = game.eng.history[game.eng.idx - 1];
              if (
                last &&
                ((last.fx === x && last.fy === y) ||
                  (last.tx === x && last.ty === y))
              ) {
                let m = document.createElement("div");
                m.className = "marker last";
                m.style.left = pos.left + "%";
                m.style.top = pos.top + "%";
                mL.appendChild(m);
              }

              if (this.sel && this.sel.x === x && this.sel.y === y) {
                let m = document.createElement("div");
                m.className = "marker select";
                m.style.left = pos.left + "%";
                m.style.top = pos.top + "%";
                mL.appendChild(m);
                if (game.eng.idx === game.eng.history.length) {
                  const tempMoves = game.eng.getLegalMoves();
                  tempMoves
                    .filter((m) => m.fx === x && m.fy === y)
                    .forEach((m) => {
                      let dPos = this.toPx(m.tx, m.ty);
                      let d = document.createElement("div");
                      d.className = "marker dot";
                      d.style.left = dPos.left + "%";
                      d.style.top = dPos.top + "%";
                      mL.appendChild(d);
                    });
                }
              }

              if (p) {
                let d = document.createElement("div");
                d.className = `piece ${p[0] === "r" ? "red" : "black"}`;
                d.dataset.char = CN_PIECES[p];
                if (p[0] === "b" && p[1] === "K")
                  d.dataset.char = CN_PIECES["k"];
                if (p[0] === "r" && p[1] === "K")
                  d.dataset.char = CN_PIECES["K"];
                d.style.left = pos.left + "%";
                d.style.top = pos.top + "%";
                pL.appendChild(d);
              }
            }
        },

        updateInfo() {
          const list = document.getElementById("history");
          const statusEl = document.getElementById("status");
          const playBtn = document.getElementById("playBtn");

          playBtn.innerText = game.isPlaying ? "||" : "▶";

          if (game.isGameOver) {
            statusEl.style.color = "yellow";
            statusEl.innerText = game.gameOverStatus;
          } else {
            statusEl.style.color = game.eng.turn === "r" ? "#ff6b6b" : "#aaa";
            statusEl.innerText =
              (game.eng.turn === "r" ? "Red" : "Black") + " to Move";
            if (game.eng.inCheck(game.eng.turn))
              statusEl.innerText += " - Check!";
          }

          list.innerHTML = "";
          let tmp = new Engine();
          if (game.startFen) game.loadFenTo(game.startFen, tmp);

          for (let i = 0; i < game.eng.history.length; i += 2) {
            let h1 = game.eng.history[i];
            let h2 = game.eng.history[i + 1];
            let not1 = game.genNotation(tmp, h1, this.reflect);
            tmp.board[h1.ty][h1.tx] = tmp.board[h1.fy][h1.fx];
            tmp.board[h1.fy][h1.fx] = null;
            let not2 = h2 ? game.genNotation(tmp, h2, this.reflect) : "";
            if (h2) {
              tmp.board[h2.ty][h2.tx] = tmp.board[h2.fy][h2.fx];
              tmp.board[h2.fy][h2.fx] = null;
            }

            let div = document.createElement("div");
            // Highlight Current Move
            let isCurr = i + 1 === game.eng.idx || i + 2 === game.eng.idx;
            div.className = "row" + (isCurr ? " current" : "");
            div.innerHTML = `<span>${
              i / 2 + 1
            }.</span><span onclick="game.goto(${
              i + 1
            })">${not1}</span><span onclick="game.goto(${
              i + 2
            })">${not2}</span>`;
            list.appendChild(div);
            if (isCurr) div.scrollIntoView({ block: "nearest" });
          }
        },

        splash(txt) {
          let el = document.getElementById("splash");
          el.innerText = txt;
          el.classList.remove("pop");
          void el.offsetWidth;
          el.classList.add("pop");
          sfx.play(440, "sine", 0.5, 0.4);
        },
      };

      const game = {
        eng: new Engine(),
        startFen:
          "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1",
        isGameOver: false,
        gameOverStatus: "",
        isPlaying: false,
        playTimer: null,

        newGame() {
          if (!confirm("Start New Game?")) return;
          this.eng.reset();
          this.startFen =
            "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1";
          document.getElementById("fenBox").value = "";
          this.stopPlay();
          ui.sel = null;
          ui.flip = false;
          ui.reflect = false;
          this.isGameOver = false;
          this.gameOverStatus = "";
          ui.init();
          sfx.play(400, "sawtooth");
        },
        reset() {
          this.newGame();
        },
        undo() {
          this.stopPlay();
          if (this.eng.idx > 0 && this.eng.idx === this.eng.history.length) {
            this.eng.history.pop();
            this.eng.idx--;
            this.eng.turn = this.eng.turn === "r" ? "b" : "r";
            let tmp = new Engine();
            this.loadFenTo(this.startFen, tmp);
            this.eng.history.forEach((m) => {
              tmp.board[m.ty][m.tx] = tmp.board[m.fy][m.fx];
              tmp.board[m.fy][m.fx] = null;
            });
            this.eng.board = tmp.board;
            this.isGameOver = false;
            ui.sel = null;
            ui.render();
            ui.updateInfo();
          }
        },

        // PLAYBACK
        goto(i) {
          this.stopPlay();
          this.eng.idx = i;
          ui.sel = null;
          ui.render();
          ui.updateInfo();
        },
        step(d) {
          let n = this.eng.idx + d;
          if (n >= 0 && n <= this.eng.history.length) this.goto(n);
        },
        togglePlay() {
          if (this.isPlaying) this.stopPlay();
          else {
            this.isPlaying = true;
            ui.updateInfo();
            this.playTimer = setInterval(() => {
              if (this.eng.idx < this.eng.history.length)
                this.goto(this.eng.idx + 1);
              else this.stopPlay();
            }, 1000);
          }
        },
        stopPlay() {
          clearInterval(this.playTimer);
          this.isPlaying = false;
          ui.updateInfo();
        },

        load() {
          let txt = document.getElementById("fenBox").value.trim();
          if (!txt) return;
          let fen = txt;
          if (txt.includes("[DhtmlXQ]")) {
            let f = txt.match(/_fen](.*?)\[/);
            if (f) fen = f[1];
          }
          if (fen.includes("/")) {
            this.eng.reset();
            this.loadFenTo(fen, this.eng);
            this.startFen = fen;
            this.isGameOver = false;
            this.gameOverStatus = "";
            this.checkGameOver();
            ui.init();
            sfx.play(500, "square");
          }
        },
        loadFenTo(fen, engine) {
          let rows = fen.split(" ")[0].split("/");
          engine.board = Array(10)
            .fill(null)
            .map(() => Array(9).fill(null));
          rows.forEach((r, y) => {
            let x = 0;
            for (let c of r) {
              if (!isNaN(c)) x += parseInt(c);
              else {
                let color = c === c.toUpperCase() ? "r" : "b";
                let t = c.toUpperCase();
                if (t === "H") t = "N";
                if (t === "B") t = "E";
                engine.board[y][x] = color + t;
                x++;
              }
            }
          });
          engine.turn = fen.split(" ")[1] || "r";
        },
        checkGameOver() {
          const moves = this.eng.getLegalMoves();
          const opp = this.eng.turn === "r" ? "b" : "r";
          const col = opp === "r" ? "Red" : "Black";
          if (moves.length === 0) {
            this.isGameOver = true;
            if (this.eng.inCheck(this.eng.turn)) {
              this.gameOverStatus = `${col} Wins (Checkmate)`;
              ui.splash("绝 杀");
            } else {
              this.gameOverStatus = `Stalemate`;
              ui.splash("闷 宫");
            }
          } else if (this.eng.inCheck(this.eng.turn)) ui.splash("將 軍");
          ui.updateInfo();
        },

        genNotation(tempEng, move, isReflect) {
          const { fx, fy, tx, ty, p } = move;
          const red = p[0] === "r";
          const type = p[1];
          let name = CN_PIECES[p];

          let srcF, dstF;
          if (!isReflect) {
            srcF = red ? 9 - fx : fx + 1;
            dstF = red ? 9 - tx : tx + 1;
          } else {
            srcF = red ? fx + 1 : 9 - fx;
            dstF = red ? tx + 1 : 9 - tx;
          }

          // Multi-piece Logic (Pawns etc)
          let sameCol = [];
          if (!["A", "E", "K"].includes(type)) {
            // Exclude King/Advisor/Elephant
            for (let y = 0; y < 10; y++)
              if (tempEng.board[y][fx] === p) sameCol.push(y);
          }

          let prefix = "";
          if (sameCol.length > 1) {
            if (red) sameCol.sort((a, b) => a - b);
            else sameCol.sort((a, b) => b - a);
            let idx = sameCol.indexOf(fy);
            if (sameCol.length === 2) prefix = idx === 0 ? "前" : "后";
            else if (sameCol.length === 3)
              prefix = idx === 0 ? "前" : idx === 1 ? "中" : "后";
            else {
              const P_MAP = ["前", "二", "三", "四", "五"];
              prefix = idx === sameCol.length - 1 ? "后" : P_MAP[idx];
            }
            name = prefix + name;
          }

          const dy = ty - fy;
          let dir = fy === ty ? "=" : (red ? dy < 0 : dy > 0) ? "+" : "-";
          let dest = "";
          if (["R", "C", "P", "K"].includes(type) && dir !== "=") {
            let dist = Math.abs(dy);
            dest = red ? CN_NUMS[dist] : CN_DIGITS[dist];
          } else {
            dest = red ? CN_NUMS[dstF] : CN_DIGITS[dstF];
          }

          if (sameCol.length > 1) return name + CN_DIR[dir] + dest;
          let fChar = red ? CN_NUMS[srcF] : CN_DIGITS[srcF];
          return name + fChar + CN_DIR[dir] + dest;
        },

        export() {
          let fen = "";
          for (let y = 0; y < 10; y++) {
            let e = 0;
            for (let x = 0; x < 9; x++) {
              let p = this.eng.board[y][x];
              if (!p) e++;
              else {
                if (e) fen += e;
                e = 0;
                let c = p[1];
                if (c === "N") c = "H";
                if (c === "E") c = "B";
                fen += p[0] === "r" ? c.toUpperCase() : c.toLowerCase();
              }
            }
            if (e) fen += e;
            if (y < 9) fen += "/";
          }
          fen += ` ${this.eng.turn} - - 0 1`;
          let mvStr = this.eng.history.map((h) => h.mv).join("");
          let tmp = new Engine();
          if (this.startFen) this.loadFenTo(this.startFen, tmp);
          let movesTxt = "";
          this.eng.history.forEach((h, i) => {
            let not = this.genNotation(tmp, h, false);
            if (i % 2 === 0) movesTxt += `${i / 2 + 1}. ${not} `;
            else movesTxt += `${not}\n`;
            tmp.board[h.ty][h.tx] = tmp.board[h.fy][h.fx];
            tmp.board[h.fy][h.fx] = null;
          });
          let output = `[DhtmlXQ_fen]${this.startFen}[/DhtmlXQ_fen]\n[DhtmlXQ_binit]${mvStr}[/DhtmlXQ_binit]\n开始局面: ${this.startFen}\n着法:\n${movesTxt}\n使用皮卡鱼象棋在线分析: https://www.xiangqiai.com`;
          document.getElementById("fenBox").value = output;
          navigator.clipboard.writeText(output);
          alert("Full Format Copied!");
        },
      };

      ui.init();
    </script>
  </body>
</html>
